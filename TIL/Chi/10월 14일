Kotlin in Action

상속의 문제점을 해결한 코틀린의 대처 방법

oepn, final, abstract 변경자

1. open
  - 자바에서는 상속이 캡슐화가 깨지는 문제가 발생할 수 있다. 그래서 오버라이드하게 의도된 클래스나 메서드가 아니면 final로 만드는 걸 추천한다.
  - 이러한 문제를 해결한 코틀린에서는 기본적으로 클래스와 메서드가 final이다.
  - 그래서 상속을 허용하려면 상위 클래스에 open 변경자를 붙여야 한다.
  - 또한 오버라이드를 허용하고 싶은 메서드나 프로퍼티에도 open 변경자를 붙여야 함.

2. final
  - 반대로 open 클래스인데 상위 클래스를 상속 받았고, 상위 클래스 오버라이딩을 한 경우에, final을 붙여서 하위 클래스에게 오버라이딩한 메서드에 접근하지 못하게 함.

3. abstract
  - 추상 클래스는 인스턴스를 만들 수 없음
  - 추상 클래스의 멤버는 항상 열려 있어서 open 변경자를 명시할 필요가 없다.


클래스 위임 by 키워드
   - 하위 클래스가 상위 클래스를 오버라이딩하면 상위 클래스의 세부 구현 사항에 의존하게 됨.
   - 그래서 위에서 처럼 final과 open 변경자를 이용하여 하위 클래스를 깨지 않게 좀 더 조심하였음.
   - 하지만 종종 상속을 허용하지 않는 클래스에 새로운 동작을 추가할 때가 있음.
   - 이때 사용하는게 데코레이터 패턴임.
   - 데코레이터 패턴은 상속을 허용하지 않는 클래스 대신 사용할 수 있는 새로운 클래스를 만들고 기존 클래스와 같은 인터페이스를 데코레이터가 제공하게하는데, 
     기존 클래스를 데코레이터 내부에 필드로 유지 시킨다. 새로 정의해야 하는 기능은 데코레이터 메서드에 새로 정의하고 기존 기능은 데코레이터 메서드가 요청을 전달한다.
   - 단점은 데코레이터 클래스를 만들라면 복잡하다. 데코레이터 준비코드가 너무 많다.
   - 이러한 데코레이터 패턴의 복잡함을 해결한게 코틀린의 by 키워드이다.
   - by 키워드를 통해 그 인터페이스에 대한 구현을 다른 객체에 위임 중이라고 명시하는 개념. ex) Collection<T> by innerList () 
   
